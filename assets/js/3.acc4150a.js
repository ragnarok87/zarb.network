(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{363:function(e,t,a){e.exports=a.p+"assets/img/pbft.aef1804b.png"},364:function(e,t,a){e.exports=a.p+"assets/img/zarb-consensus.d600071e.png"},365:function(e,t,a){e.exports=a.p+"assets/img/delegated_proof_of_stake.228eb4b9.jpg"},366:function(e,t,a){e.exports=a.p+"assets/img/zarb_validator_pool.af9f5349.jpg"},381:function(e,t,a){"use strict";a.r(t);var o=a(25),r=Object(o.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"consensus-engine"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#consensus-engine"}},[e._v("#")]),e._v(" Consensus Engine")]),e._v(" "),o("h2",{attrs:{id:"practical-byzantine-fault-tolerant"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#practical-byzantine-fault-tolerant"}},[e._v("#")]),e._v(" Practical Byzantine Fault Tolerant")]),e._v(" "),o("p",[e._v('Zarb is based on Proof-of-Stake and uses Practical Byzantine Fault Tolerant (PBFT) for its consensus engine. There are other protocols for consensus engine like Paxos and Raft. However Paxos and Raft protocols aren’t Byzantine fault tolerant. The original paper is published on 1999. "This paper presents a new, practical algorithm for state machine replication that tolerates Byzantine faults."')]),e._v(" "),o("p",[e._v("In PBFT")]),e._v(" "),o("ol",[o("li",[e._v("A client sends a request to invoke a service operation to the primary (P)")]),e._v(" "),o("li",[e._v("The primary multicasts the request to the backups")]),e._v(" "),o("li",[e._v("Replicas execute the request and send a reply to the client")]),e._v(" "),o("li",[e._v("The client waits for 3f+1 replies from different replicas with the same result; this is the result of the operation.")])]),e._v(" "),o("p",[e._v("3f+1 means if there are f nodes that has a byzantine failure, there has to be more than 3f+1 nodes in order for the system to be byzantine fault tolerant.")]),e._v(" "),o("p",[e._v("When the primary receives a client request it starts a three-phase protocol to atomically multicast the request to the replicas. The three phases are pre-prepare, prepare, and commit.")]),e._v(" "),o("p",[e._v("The algorithm provides both safety and liveness assuming no more than 3f+1 replicas are faulty.")]),e._v(" "),o("p",[e._v("Picture below shows the operation of the algorithm in the normal case of no primary faults. Replica 0 is the primary, replica 3 is faulty, and C is the client.")]),e._v(" "),o("p",[o("img",{attrs:{src:a(363),alt:"Normal execution of the Practical Byzantine Fault Tolerance (PBFT) protocol"}})]),e._v(" "),o("h2",{attrs:{id:"zarb-consensus-engine"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#zarb-consensus-engine"}},[e._v("#")]),e._v(" Zarb Consensus Engine")]),e._v(" "),o("p",[e._v("Zarb consensus engine inspired by PBFT. In each height a proposer start broadcasting a proposal block to validators. Validators  validate, execute and vote for the incoming block. If more than 2/3 of validators vote for a block, the block will be committed otherwise validators move to the next round or view.")]),e._v(" "),o("p",[e._v("The three phases in Zarb consensus are Prepare and precommit and commit\n"),o("img",{attrs:{src:a(364),alt:"Zarb consensus mechanism"}})]),e._v(" "),o("h2",{attrs:{id:"a-paradox"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#a-paradox"}},[e._v("#")]),e._v(" A paradox")]),e._v(" "),o("p",[e._v("Unlike Proof of Work, which is based on competition between miners, Proof of Stake is based on cooperation between validators. Validators work together to validate a block, like a team. A good player will be incentivized and a bad actor will be punished and fired from the team. However, the question is how big this team or validator set can be?")]),e._v(" "),o("p",[e._v("If your validator set gets big and bigger, the voting time will be loner and longer and also the set will be more vulnerable in network partition attack. For example, some calculation shows that with more than 100 validators, PoS blockchain becomes less efficient.")]),e._v(" "),o("p",[e._v("In the other hand a blockchain will be more secure and decentralized if more validators participated on it. We have to secure blockchain with more validators but technically we can't achieve it. Here is a paradox!")]),e._v(" "),o("p",[e._v("The block size can be another issue when the number of validators increase. Validators must put their signature information in each block as proof of the commit. As long as more than 2/3 of validators sign a block, the block will be committed into the blockchain. Increasing the size of validator set will increase the size of block and blockchain.")]),e._v(" "),o("h2",{attrs:{id:"delegated-proof-of-stake"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#delegated-proof-of-stake"}},[e._v("#")]),e._v(" Delegated Proof of Stake")]),e._v(" "),o("p",[e._v("Some blockchain solves this paradox by defining delegation, Delegated Proof of Stake (dPoS), people put their stakes in hand of a group of ‘delegates’ and these delegates validate transactions and produce blocks.")]),e._v(" "),o("p",[e._v("But how can voters trust a delegate? If a delegate is acting badly, what will happen? You can stake your token in favor of good actors. But you still need a minimum trust on this platform. We know in the blockchain, the main concept is not trusting anyone. This is another paradox in dPoS.")]),e._v(" "),o("p",[e._v("For example in the EOS blockchain, there is "),o("a",{attrs:{href:"https://github.com/EOSIO/eos/blob/5068823fbc8a8f7d29733309c0496438c339f7dc/constitution.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("constitution"),o("OutboundLink")],1),e._v(" for the people participating in the blockchain. This constitution is full of “shall” and “shall not”. In the long run, this blockchain will be ruled by a powerful organization and won’t be decentralized anymore.")]),e._v(" "),o("p",[o("img",{attrs:{src:a(365),alt:"Delegated Proof of Stake"}})]),e._v(" "),o("h2",{attrs:{id:"zarb-has-no-delegation"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#zarb-has-no-delegation"}},[e._v("#")]),e._v(" Zarb has no delegation")]),e._v(" "),o("p",[e._v("The solution we are offering in Zarb is creating a "),o("strong",[e._v("dynamic set")]),e._v(" of validators. Validators can be changed randomly. Anyone can easily become a validator by staking some tokens. In each height, every validator starts running a Verifiable Random Function (VRF) in order to self-choose themselves. The VRF is absolutely random and the result can be verified cryptographically. Based on their stake and their chance, a validator can be in the set for the next run. Once a validator enters the set, the oldest validator in the set exits. So we can always guarantee that validators are in the set for a certain amount of time. In the set, validators have equal power and it helps to make a fully democratic set for the blockchain.")]),e._v(" "),o("p",[o("img",{attrs:{src:a(366),alt:"Zarb Proof of Stake"}})]),e._v(" "),o("h2",{attrs:{id:"how-vrf-works"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#how-vrf-works"}},[e._v("#")]),e._v(" How VRF works?")]),e._v(" "),o("p",[e._v("In each height validators outside the set run a VRF function which the seed is the previous block hash. The result is deterministic and Zero Knowledge provable. A validator based on its stake and its luck can enter the set for the next height. The formula is quite simple:")]),e._v(" "),o("p",[o("img",{attrs:{src:"https://render.githubusercontent.com/render/math?math=R\\=V\\times S_{t}"}}),o("br"),e._v(" "),o("em",[e._v("which")]),o("br"),e._v(" "),o("img",{attrs:{src:"https://render.githubusercontent.com/render/math?math=V"}}),e._v(": VRF output between 0~1"),o("br"),e._v(" "),o("img",{attrs:{src:"https://render.githubusercontent.com/render/math?math=S_{t}"}}),e._v(": Total stake"),o("br")]),e._v(" "),o("p",[e._v("If the result is less than the validator stake, then this validator is eligible to enter to the set for the next height. The validator needs to send a Sortition transaction with the proof of VRF. This transaction is valid for 21 blocks. When a validator enters the set the latest validator should leave the set to make it balance.")]),e._v(" "),o("h2",{attrs:{id:"references"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),o("ul",[o("li",[o("a",{attrs:{href:"http://pmg.csail.mit.edu/papers/osdi99.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("PracticalByzantineFaultTolerance"),o("OutboundLink")],1)]),e._v(" "),o("li",[o("a",{attrs:{href:"https://tendermint.com/static/docs/tendermint.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Tendermint:  Consensus without Mining"),o("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=r.exports}}]);