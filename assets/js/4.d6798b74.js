(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{367:function(t,a,e){t.exports=e.p+"assets/img/stamped_tx.ba3f73ed.png"},368:function(t,a,e){t.exports=e.p+"assets/img/btc-block-size.8d3edb74.png"},369:function(t,a,e){t.exports=e.p+"assets/img/btc-blockchain-size.b6aa045b.png"},395:function(t,a,e){"use strict";e.r(a);var n=e(25),s=Object(n.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"stamping-transactions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#stamping-transactions"}},[t._v("#")]),t._v(" Stamping transactions")]),t._v(" "),n("h2",{attrs:{id:"what-is-stamping-transaction"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#what-is-stamping-transaction"}},[t._v("#")]),t._v(" What is stamping transaction?")]),t._v(" "),n("p",[n("em",[t._v("Stamping a transaction")]),t._v(" simply means putting the previous block hash into the header of the transaction.\nA "),n("em",[t._v("stamped transaction")]),t._v(" unlike normal transactions has a lifetime (TTL) and it's only valid for a certain time. If "),n("code",[t._v("TTL = N")]),t._v(", the stamped transaction after "),n("code",[t._v("N")]),t._v(" blocks will be invalid.")]),t._v(" "),n("p",[t._v("By stamping transactions we can decouple transactions from the block. There is no need to save the whole transaction inside a block and keeping the transaction hash is fair enough.")]),t._v(" "),n("p",[n("img",{attrs:{src:e(367),alt:"Stamping transaction"}})]),t._v(" "),n("h3",{attrs:{id:"how-to-validate-a-stamped-transaction"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#how-to-validate-a-stamped-transaction"}},[t._v("#")]),t._v(" How to Validate a stamped transaction")]),t._v(" "),n("p",[t._v("A stamped transaction easily can be verified.\nThe first step is finding the block with the corresponding stamp (block hash).\nIf it doesn’t exist it means the transaction is not valid.\nIf the block is found, we need to iterate over the next "),n("code",[t._v("N")]),t._v(" blocks to find the transaction hash.\nIf the transaction hash found, it is valid otherwise the transaction is invalid.")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("tx is valid if:\n\nhash(tx) ∊ Block[S:S+N]\n\nwhere:\n  Block[S] = tx.stamp\n\n")])])]),n("h3",{attrs:{id:"where-stamped-transactions-will-be-saved"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#where-stamped-transactions-will-be-saved"}},[t._v("#")]),t._v(" Where stamped transactions will be saved?")]),t._v(" "),n("p",[t._v("Full nodes can have a separate database for saving stamped transactions.\nThis database will only be used for querying transactions. A node can choose to save all txs, part of them or nothing.\nNodes can query transactions by hash from each other. Users also can save their own transactions in their own wallets.")]),t._v(" "),n("h3",{attrs:{id:"can-a-stamped-transaction-be-lost"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#can-a-stamped-transaction-be-lost"}},[t._v("#")]),t._v(" Can a stamped transaction be lost?")]),t._v(" "),n("p",[t._v("Probably yes and it's not a curse. Should we care about a transaction that happened 10 years ago and try to keep it in our DB?\nBy decoupling transactions from the block, transactions will have their own way to survive.")]),t._v(" "),n("h2",{attrs:{id:"consequences"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#consequences"}},[t._v("#")]),t._v(" Consequences")]),t._v(" "),n("ul",[n("li",[n("p",[n("strong",[t._v("Reducing the size of blockchain")])]),t._v(" "),n("p",[t._v("Stamping transactions can reduce the block size dramatically. For keeping a stamped transaction inside a block we need to store only 32 bytes of hash of transaction instead of whole transaction data. In bitcoin, the average transaction size has increased from 450 bytes in Jan 2013 to almost 600 bytes in Oct 2015. In the below charts you can see how stamped transaction could reduce the size of bitcoin blockchain if it had applied from the genesis block:")]),t._v(" "),n("p",[n("img",{attrs:{src:e(368),alt:"Bitcoin average block size"}})]),t._v(" "),n("p",[n("img",{attrs:{src:e(369),alt:"Bitcoin blockchain size"}})])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("Reducing the size of mempool")])]),t._v(" "),n("p",[t._v("Each stamped transaction has a lifetime and the transaction will be invalid after a certain time. It can help manage the mempool better and avoid keeping transactions with low free forever.")])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("Preventing any possible forks")])]),t._v(" "),n("p",[t._v("Stamped transactions are loyal to the main fork. Any possible fork needs to re-stamp the transactions and therefore re-sign them which is not feasible. This feature specially can mitigate "),n("em",[t._v("Nothing at stake")]),t._v(" and "),n("em",[t._v("long range")]),t._v(" attacks for Proof of Stake blockchains. There is no solution to overcome long range attacks in PoS blockchain. Stamping transactions can mitigate this issue by binding transactions to the main fork.")])])]),t._v(" "),n("h2",{attrs:{id:"references"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[t._v("#")]),t._v(" References")]),t._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://tradeblock.com/blog/analysis-of-bitcoin-transaction-size-trends",target:"_blank",rel:"noopener noreferrer"}},[t._v("Analysis of Bitcoin Transaction Size Trends"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"https://blog.ethereum.org/2015/01/10/light-clients-proof-stake/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Light Clients and Proof of Stake"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8653269",target:"_blank",rel:"noopener noreferrer"}},[t._v("A Survey on Long-Range Attacks for Proof of Stake Protocols"),n("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=s.exports}}]);